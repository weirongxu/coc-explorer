import Pkg from '../package.json';
import fs from 'fs';
import { JSONSchema7 } from 'json-schema';

const fsp = fs.promises;

type Definition = JSONSchema7;
type Cmd = {
  title: string;
  command: string;
};

type Row = {
  key: string;
  description?: string;
  type?: string;
  default?: string;
};

const hint = "<!-- Generated by 'yarn run gen:doc', please don't edit it directly -->";
const ignorePrettier = '<!-- prettier-ignore -->';

async function attach(headLevel: number, attachTitle: string, markdownPath: string, rows: Row[]) {
  const markdown = await fsp.readFile(markdownPath, 'utf8');
  const markdownLines = markdown.split('\n');
  let startIndex = markdownLines.findIndex((line) =>
    new RegExp('#'.repeat(headLevel) + '\\s*' + attachTitle + '\\s*').test(line),
  );
  if (startIndex < 0) {
    return;
  }
  startIndex += 1;
  const endIndex = markdownLines
    .slice(startIndex)
    .findIndex((line) => new RegExp('#'.repeat(headLevel) + '[^#]').test(line));
  const removeCount = endIndex < 0 ? 0 : endIndex;
  const lines: string[] = ['', hint, ignorePrettier];
  rows.forEach((row) => {
    let line = `- \`${row.key}\``;
    const descriptions: string[] = [];
    if (row.description) {
      descriptions.push(row.description);
    }
    if (row.type) {
      descriptions.push(`type: \`${row.type}\``);
    }
    if (row.default) {
      descriptions.push(`default: \`${row.default}\``);
    }
    if (descriptions.length) {
      line += ': ' + descriptions.join(', ');
    }
    lines.push(line);
  });
  lines.push('');
  markdownLines.splice(startIndex, removeCount, ...lines);
  await fsp.writeFile(markdownPath, markdownLines.join('\n'));
}

// function genCommandDoc() {
//   const cmds = Pkg.contributes.commands as Cmd[];
//   const rows: Row[] = [];
//   cmds.forEach((cmd) => {
//     rows.push({
//       key: cmd.command,
//       description: cmd.title,
//     });
//   });
//   return rows;
// }

function genConfigurationDoc() {
  const conf = Pkg.contributes.configuration.properties;
  const rows: Row[] = [];
  for (const property in conf) {
    const def = Reflect.get(conf, property) as Definition & { default_doc?: string };
    const row: Row = {
      key: property,
      description: def.description,
    };
    if (def.enum) {
      row.type = def.enum.join(' | ');
    } else if (typeof def.type === 'string') {
      row.type = def.type;
    } else {
      row.type = JSON.stringify(def.type);
    }
    if (def.default_doc) {
      if (typeof def.default_doc === 'string') {
        row.default = def.default_doc === '' ? '`[empty]`' : def.default_doc;
      } else {
        row.default = JSON.stringify(def.default_doc);
      }
    } else if (def.default !== undefined) {
      if (typeof def.default === 'string') {
        row.default = def.default === '' ? '`[empty]`' : def.default;
      } else {
        row.default = JSON.stringify(def.default);
      }
    }
    rows.push(row);
  }
  return rows;
}

async function main() {
  // await attach(2, 'Commands', 'readme.md', genCommandDoc());
  // console.log('attach to Commands');
  await attach(2, 'Configuration', 'readme.md', genConfigurationDoc());
  console.log('attach to Configuration');
}

main().catch((error) => console.error(error));
